import * as React from 'react';
import './App.scss';
import hub from './icons/hub.svg';
import data from './vulnerability-data.json';
import BarChart from './lib/BarChart';
import CompactList from './lib/CompactList';
import Modal from './lib/Modal';
import HostView from './lib/HostView';
import {
	formatTitle,
	lowFloor,
	lowCeiling,
	mediumFloor,
	mediumCeiling,
	highFloor,
	highCeiling,
	criticalFloor,
	riskType,
	getIdentificationCommonHosts,
	sortByIdentificationType,
	getBarData,
} from './lib/Common';

const App = () => {
	const cveArray = Object.keys(data).map(key => data[key]);
	const [populateDenseModal, setPopulateDenseModal] = React.useState([]);
	const [showDenseModal, setShowDenseModal] = React.useState(false);
	const [populateCompactModal, setPopulateCompactModal] = React.useState([]);
	const [showCompactModal, setShowCompactModal] = React.useState(false);
	const [sort, setSort] = React.useState(true);
	const [sortType, setSortType] = React.useState('risk');
	const [workingObject, setWorkingObject] = React.useState({});
	const [workingRequest, setWorkingRequest] = React.useState();
	const riskMap = {
		low: {
			effectedHosts: [],
			commonHosts: [],
			items: [],
		},
		medium: {
			effectedHosts: [],
			commonHosts: [],
			items: [],
		},
		high: {
			effectedHosts: [],
			commonHosts: [],
			items: [],
		},
		critical: {
			effectedHosts: [],
			commonHosts: [],
			items: [],
		},
	};

	// in order to dynamically populate the map with an
	// unknown number of identification types (CVE/DSS), 
	// this is not typed ahead
	const identificationMap = {};

	// seeing how many common hosts are being effected at each level
	// could lead to seeing interesting trends
	const getCommonHosts = (level) => {
		let tempLevel;

		switch (level) {
			case 'critical':
				tempLevel = riskMap.critical.effectedHosts
				break;
			case 'high':
				tempLevel = riskMap.high.effectedHosts
				break;
			case 'medium':
				tempLevel = riskMap.medium.effectedHosts
				break;
			case 'low':
				tempLevel = riskMap.low.effectedHosts
				break;
			default:
				break;
		}

		return tempLevel.filter((item, index) => index !== tempLevel.indexOf(item));
	};

	// sorted by risk factor overall
	// group CVEs by level (most common view)
	cveArray.sort((a, b) => a.risk > b.risk ? -1 : 1).forEach(
		item => {
			if (item.risk >= lowFloor && item.risk < lowCeiling) {
				riskMap.low.effectedHosts.push(...item.hosts);
				riskMap.low.items.push(item);
			} else if (item.risk > mediumFloor && item.risk < mediumCeiling) {
				riskMap.medium.effectedHosts.push(...item.hosts);
				riskMap.medium.items.push(item);
			} else if (item.risk > highFloor && item.risk < highCeiling) {
				riskMap.high.effectedHosts.push(...item.hosts);
				riskMap.high.items.push(item);
			} else if (item.risk > criticalFloor) {
				riskMap.critical.effectedHosts.push(...item.hosts);
				riskMap.critical.items.push(item);
			}
		}
	);

	// now that we have all the hosts for each level,
	// lets get hosts that share vulnerabilities
	riskMap.low.commonHosts = getCommonHosts('low');
	riskMap.medium.commonHosts = getCommonHosts('medium');
	riskMap.high.commonHosts = getCommonHosts('high');
	riskMap.critical.commonHosts = getCommonHosts('critical');

	// by identification (Year/CVE/DSS)
	// get all possibilities
	let identificationType = [];
	cveArray.sort((a, b) => a.identifier > b.identifier ? -1 : 1).forEach(
		item => {
			const parsedYear = item.identifier.slice(0, 8);
			if (!identificationType.includes(parsedYear)) {
				identificationType.push(parsedYear);
			}
		}
	);

	// putting the items in their correct dynamic slots
	const fillIdentificationMap = () => {
		for (let i = 0; i < identificationType.length; i++) {
			const sorted = sortByIdentificationType(identificationType[i], cveArray).sort((a, b) => a.risk > b.risk ? -1 : 1);
			const effectedHosts = [];

			sorted.map(item => effectedHosts.push(...item.hosts));

			const obj = Object.assign({}, {
				items: sorted,
				effectedHosts: effectedHosts,
				commonHosts: getIdentificationCommonHosts(effectedHosts),
			});

			identificationMap[identificationType[i]] = obj;

		}
	};

	fillIdentificationMap();

	// handle any click and populate the correct modal
	const handleTotalClick = (result, request) => {
		// slow area - look into
		setWorkingObject(result);
		setWorkingRequest(request);
	};

	const sortRisk = () => {
		setSort(!sort);
		setSortType('risk');
		!sort
			? workingObject.items.sort((a, b) => a.risk > b.risk ? -1 : 1)
			: workingObject.items.sort((a, b) => a.risk > b.risk ? 1 : -1);
	};

	const sortTitle = () => {
		setSort(!sort);
		setSortType('identifier');
		!sort
			? workingObject.items.sort((a, b) => a.identifier > b.identifier ? -1 : 1)
			: workingObject.items.sort((a, b) => a.identifier > b.identifier ? 1 : -1);
	};

	React.useEffect(() => {
		// populate based on filters
		const populateProper = () => {
			switch (workingRequest) {
				case 'total':
					setPopulateDenseModal(workingObject.items);
					setShowDenseModal(true);
					break;
				case 'hosts':
					setPopulateCompactModal(workingObject.effectedHosts);
					setShowCompactModal(true);
					break;
				case 'common':
					setPopulateCompactModal(workingObject.commonHosts);
					setShowCompactModal(true);
					break;
				default:
					break;
			}
		};
		populateProper();
	}, [workingObject, workingRequest]);

	const MetricList = ({ title, type }) => {
		const result = type === 'identificationMap' ? identificationMap[title] : riskMap[title];
		return (
			<ul className='metrics-list'>
				<li onClick={() => handleTotalClick(result, 'total')}>
					<p>total</p>
					<span>{result.items.length}</span>
				</li>
				<li onClick={() => handleTotalClick(result, 'hosts')}>
					<p>effected hosts</p>
					<span>{result.effectedHosts.length.toLocaleString("en-US")}</span>
				</li>
				<li onClick={() => handleTotalClick(result, 'common')}>
					<p>effected hosts in common</p>
					<span>{result.commonHosts.length.toLocaleString("en-US")}</span>
				</li>
			</ul>
		)
	};

	return (
		<div className='main'>
			<Modal show={showDenseModal} onClose={() => setShowDenseModal(false)}>
				<CompactList items={populateDenseModal} sort={sort} sortType={sortType} sortRisk={sortRisk} sortTitle={sortTitle} />
			</Modal>
			<Modal show={showCompactModal} onClose={() => setShowCompactModal(false)}>
				<HostView items={populateCompactModal} />
			</Modal>
			<main className='page'>
				<section className='welcome'>
					<div className='welcome-wrapper'>
						<img src={hub} alt='hub' />
						<h1>CVE Data Hub</h1>
						<p>Interact with the cards below to learn more...</p>
					</div>
				</section>
				<section className='overview'>
					<h2>Overview</h2>
					<div className='overview-metrics-wrapper'>
						{riskType.map((title, index) => (
							<div className={`metric-block ${title}`} key={index}>
								<h3>{formatTitle(title)}</h3>
								<span className={`identifier-orb ${title}`}/>
								<MetricList title={title} type='riskMap' />
							</div>
						))
						}
					</div>
					<div className='barchart-wrapper'>
						<>
							<h4>Risk Totals</h4>
							<BarChart data={getBarData(riskMap)} />
						</>
					</div>
				</section>
				<section className='identification'>
					<h2>Identification (Year/CVE/DSS)</h2>
					<div className='identification-metrics-wrapper'>
						{identificationType.map((title, index) => (
							<div className='metric-block standard' key={index}>
								<h3>{title}</h3>
								<MetricList title={title} type='identificationMap' />
							</div>
						))
						}
					</div>
				</section>
			</main>
		</div>
	);
};

export default App;
